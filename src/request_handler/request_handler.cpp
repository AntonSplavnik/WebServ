#include "request_handler.hpp"
#include "connection.hpp"
#include <sys/stat.h>
#include <dirent.h>
#include <sstream>

// Generate HTML directory listing
static std::string generateDirectoryListing(const std::string& dirPath, const std::string& requestPath) {
	std::ostringstream html;
	
	html << "<!DOCTYPE html>\n"
	     << "<html>\n<head>\n"
	     << "<meta charset=\"UTF-8\">\n"
	     << "<title>Index of " << requestPath << "</title>\n"
	     << "<style>\n"
	     << "body { font-family: 'Courier New', monospace; margin: 20px; background: #f5f5f5; }\n"
	     << "h1 { color: #333; border-bottom: 2px solid #0066cc; padding-bottom: 10px; }\n"
	     << "a { display: block; padding: 8px; text-decoration: none; color: #0066cc; }\n"
	     << "a:hover { background-color: #e0e0e0; border-radius: 4px; }\n"
	     << ".dir { font-weight: bold; }\n"
	     << "hr { border: 1px solid #ccc; }\n"
	     << "</style>\n"
	     << "</head>\n<body>\n"
	     << "<h1>Index of " << requestPath << "</h1>\n<hr>\n<pre>\n";
	
	DIR* dir = opendir(dirPath.c_str());
	if (!dir) {
		return "<html><body><h1>Error: Unable to read directory</h1></body></html>";
	}
	
	struct dirent* entry;
	while ((entry = readdir(dir)) != NULL) {
		std::string name = entry->d_name;
		
		// Skip current directory "."
		if (name == ".") continue;
		
		// Build full filesystem path
		std::string fullPath = dirPath;
		if (fullPath[fullPath.length() - 1] != '/')
			fullPath += '/';
		fullPath += name;
		
		// Check if it's a directory
		struct stat st;
		bool isDir = false;
		if (stat(fullPath.c_str(), &st) == 0) {
			isDir = S_ISDIR(st.st_mode);
		}
		
		// Build URL link
		std::string link = requestPath;
		if (link[link.length() - 1] != '/')
			link += '/';
		link += name;
		if (isDir)
			link += '/';
		
		// Add entry to HTML
		if (isDir) {
			html << "<a href=\"" << link << "\" class=\"dir\">" << name << "/</a>\n";
		} else {
			html << "<a href=\"" << link << "\">" << name << "</a>\n";
		}
	}
	
	closedir(dir);
	
	html << "</pre>\n<hr>\n<p><em>Generated by Webserv42/1.0</em></p>\n</body>\n</html>";
	return html.str();
}

// Try to serve index file from directory
bool RequestHandler::tryServeIndexFile(Connection& connection, const std::string& dirPath, const LocationConfig* location) {
	std::string indexPath = dirPath;
	if (indexPath[indexPath.length() - 1] != '/')
		indexPath += '/';
	
	// Extract just the filename from location->index
	std::string indexFile = location->index;
	size_t lastSlash = indexFile.find_last_of('/');
	if (lastSlash != std::string::npos) {
		indexFile = indexFile.substr(lastSlash + 1);
	}
	
	indexPath += indexFile;
	
	// Try to open index file
	std::ifstream indexFileStream(indexPath.c_str(), std::ios::binary);
	if (!indexFileStream.is_open()) {
		return false;
	}
	
	// Read index file content
	std::stringstream buffer;
	buffer << indexFileStream.rdbuf();
	std::string content = buffer.str();
	indexFileStream.close();
	
	// Update mapped path for proper MIME type detection
	connection.setMappedPath(indexPath);
	
	connection.setStatusCode(200);
	connection.setBodyContent(content);
	connection.prepareResponse();
	return true;
}

// Serve directory listing (autoindex)
void RequestHandler::serveDirectoryListing(Connection& connection, const std::string& dirPath) {
	std::string listing = generateDirectoryListing(dirPath, connection.getRequest().getPath());
	connection.setStatusCode(200);
	connection.setBodyContent(listing);
	connection.prepareResponse();
}

// Serve regular file
void RequestHandler::serveRegularFile(Connection& connection, const std::string& filePath) {
	std::ifstream file(filePath.c_str(), std::ios::binary);
	if (!file.is_open()) {
		connection.setStatusCode(errno == EACCES ? 403 : 404);
		connection.prepareResponse();
		return;
	}

	// Read file content
	std::stringstream buffer;
	buffer << file.rdbuf();
	std::string content = buffer.str();
	file.close();

	// Check read errors
	if (content.empty() && errno) {
		connection.setStatusCode(500);
		connection.prepareResponse();
		return;
	}

	// Success
	connection.setStatusCode(200);
	connection.setBodyContent(content);
	connection.prepareResponse();
}

void RequestHandler::handleGET(Connection& connection) {
	const std::string& path = connection.getRoutingResult().mappedPath;
	const LocationConfig* location = connection.getRoutingResult().location;
	
	// Check if path exists
	struct stat pathStat;
	if (stat(path.c_str(), &pathStat) != 0) {
		connection.setStatusCode(404);
		connection.prepareResponse();
		return;
	}
	
	// Handle directory
	if (S_ISDIR(pathStat.st_mode)) {
		// Try to serve index file
		if (tryServeIndexFile(connection, path, location)) {
			return;
		}
		
		// No index file - check autoindex
		if (location->autoindex) {
			serveDirectoryListing(connection, path);
		} else {
			connection.setStatusCode(403);
			connection.prepareResponse();
		}
		return;
	}
	
	// Handle regular file
	serveRegularFile(connection, path);
}

void RequestHandler::handleDELETE(Connection& connection) {

	const std::string& path = connection.getRoutingResult().mappedPath;
	std::ifstream file(path.c_str());
	if (file.is_open()) {
		file.close();
		if(std::remove(path.c_str()) == 0) {
			connection.setStatusCode(204);
			std::cout << "[DEBUG] Succes: 204 file deleted" << std::endl;
		} else {
			connection.setStatusCode(403);
			std::cout << "[DEBUG] Error: 403 permission denied" << std::endl;
		}
	} else {
		connection.setStatusCode(404);
		std::cout << "[DEBUG] Error: 404 path is not found" << std::endl;
	}
	connection.prepareResponse();
}
void RequestHandler::handlePOST(Connection& connection) {

	const std::string& path = connection.getRoutingResult().mappedPath;
	std::cout << "[DEBUG] UploadPath: " << path << std::endl;
	PostHandler post(path);

	const HttpRequest& request = connection.getRequest();

	std::string contentType = request.getContentType();
	std::cout << "[DEBUG] POST Content-Type: '" << contentType << "'" << std::endl;
	std::cout << "[DEBUG] Request valid: " << (request.getStatus() ? "true" : "false") << std::endl;

	if (contentType.find("multipart/form-data") != std::string::npos) {
		if(post.handleMultipart(connection)) {
			connection.setState(WRITING_DISK);
		} else {
			connection.setStatusCode(400);
			connection.prepareResponse();
		}
	} else if (post.isSupportedContentType(contentType)) {
		post.handleFile(connection, contentType);
		connection.setState(WRITING_DISK);
	} else {
		std::cout << "[DEBUG] Unsupported Content-Type: " << contentType << std::endl;
		connection.setStatusCode(415);
		connection.prepareResponse();;
	}

}

void RequestHandler::handleRedirect(Connection& connection) {
	const LocationConfig* location = connection.getRoutingResult().location;
	
	// Set redirect status code and location
	connection.setStatusCode(location->redirect_code);
	connection.setRedirectLocation(location->redirect);
	connection.prepareResponse();
}
